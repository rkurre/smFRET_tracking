%Matlab script to track smFRET data obtained by the Matlab software
%FRET_efficiency_analysis published by Winkelmann et al.
%(https://doi.org/10.1038/s41467-024-49876-9). FRET efficiency analysis is
%a batch script to analyze multiple datasets (individual cells). It
%generates a table of pooled FRET efficiency and stoichiometry data for
%single-molecule FRET events including there localizations and time-points. 
% This data is used here to generate trajectories based on nearest- 
% neighbor tracking including gap closing (if an emitter signal got lost 
% due to blinking). User needs to define the following parameters
%
%Input parameters
% D: rough estimate of the 2D diffusion constant of the molecules to track.
% dt: Temporal resolution of input data.
% nFrGapClosure: Maximum number of frames to consider for gap closing.
% pxlSz: Pixel size of raw data.
% nPxlX: Horizontal resolution of input images in pixels.
% nPxlY: Vertical resolution of input images in pixels.
% trLenForPlot: Minimal track length for final plotting of trajectories
%Main outputs:
% particleTracks: Structure array with all tracks without considering gap
%                 closing. Each field (row) is a full track with 12 entries
%                 (columns): cell #, track id, time [s], x [µm], y [µm], 
%                 FRET efficiency E_raw, FRET efficiency EPR, corrected FRET
%                 efficiency E, stoichiometry S_raw, stoichiometry SPR,
%                 gamma corrected stoichiometry S_gamma, gamma and beta
%                 corrected stoichiometry S_gammabeta
% particleTracksGapClosure: Same structure array as particleTracks, but 
%                           considering gap closure to assemble final tracks 
% Figure showing all trajectories above user defined track length threshold.  
% mat file containg all variables.

% After starting the script user need to load txt file containing pooled 
% E-S table and define folder to save results.  
%
%Date: 01/08/2025
%written by Rainer Kurre (rainer.kurre@uos.de)
%Center for Cellular Nanoanalytics and Division of Biophysics
%Osnabrueck University, Barabastr. 11, D-49076 Osnabrück

% Parameters
D = 0.1;  % Diffusion constant (µm^2/s)
dt = 0.05; % Time between frames in seconds (adjust if needed)
nFrGapClosure = 5;
maxStep = 3*sqrt(4*D*dt); % Maximum step distance in µm
maxStepGapClosure = 3*sqrt(4*D*dt);
pxlSz = 0.1; %units of microns
nPxlX = 256; %Horizontal resolution of input images in pixels
nPxlY = 256; %Vertical resolution of input images in pixels
trLenForPlot = 5; %minimal track length for plotting
cmap = parula(256);
colormap(cmap);
showNNplots = 0;
xmax = nPxlX*pxlSz;
ymax = nPxlY*pxlSz;

%% Import data from text file
% Script for importing data from the following text file:
%
%    filename: ..\Pooled_E-S-Data.txt
%
% Auto-generated by MATLAB on 14-Feb-2025 11:28:59

%% Set up the Import Options and import the data
opts = delimitedTextImportOptions("NumVariables", 17);

% Specify range and delimiter
opts.DataLines = [2, Inf];
opts.Delimiter = ",";

% Specify column names and types
opts.VariableNames = ["File", "xPospx", "yPospx", "Timeframe", ...
    "DonorSignalphoton", "DonorCrossEmissionphoton", ...
    "FRETSignalphoton", "AcceptorSignalphoton", "Eraw", "EPR", ...
    "E", "Sraw", "SPR", "Sgamma", "Sgammabeta", "isFRET", "Inlier"];
opts.VariableTypes = ["double", "double", "double", "double", "double", ...
    "double", "double", "double", "double", "double", "double", ...
    "double", "double", "double", "double", "double", "double"];

% Specify file level properties
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";

% Specify variable properties
opts = setvaropts(opts, ["File", "xPospx", "yPospx", "Timeframe", ...
    "DonorSignalphoton", "DonorCrossEmissionphoton", "FRETSignalphoton",...
    "AcceptorSignalphoton", "Eraw", "EPR", "E", "Sraw", "SPR", ...
    "Sgamma", "Sgammabeta", "isFRET", "Inlier"], "ThousandsSeparator", ",");

[fileName, filePath] = uigetfile(".txt");
saveDir = uigetdir;
% Import the data
tbl = readtable([filePath, fileName], opts);

%% Convert to output type
% isFRET = logical(tbl.isFRET);
% Inlier = logical(tbl.Inlier);
% isValid = isFRET & Inlier;
isValid = true(size(tbl,1),1);
File = tbl.File(isValid);
xPospx = tbl.xPospx(isValid);
yPospx = tbl.yPospx(isValid);
Timeframe = tbl.Timeframe(isValid);
DonorSignalphoton = tbl.DonorSignalphoton(isValid);
DonorCrossEmissionphoton = tbl.DonorCrossEmissionphoton(isValid);
FRETSignalphoton = tbl.FRETSignalphoton(isValid);
AcceptorSignalphoton = tbl.AcceptorSignalphoton(isValid);
Eraw = tbl.Eraw(isValid);
EPR = tbl.EPR(isValid);
E = tbl.E(isValid);
Sraw = tbl.Sraw(isValid);
SPR = tbl.SPR(isValid);
Sgamma = tbl.Sgamma(isValid);
Sgammabeta = tbl.Sgammabeta(isValid);

%% Clear temporary variables
clear opts tbl

nFiles = File(end);
nTracks = zeros(1,nFiles);
nTracksGapClosure = zeros(1,nFiles);
% Initialize particle tracks
particleTracks = struct('cell', [], 'id', [], 'time_s', [], 'x_um', ...
    [], 'y_um', [], 'Eraw', [], 'EPR', [], 'E', [], 'Sraw', [], ...
    'SPR', [], 'Sgamma', [],'Sgammabeta', []);

particleTracksGapClosure = struct('cell', [], 'id', [], 'time_s', ...
    [], 'x_um', [], 'y_um', [], 'Eraw', [], 'EPR', [], 'E', [], ...
    'Sraw', [], 'SPR', [], 'Sgamma', [],'Sgammabeta', []);

for f=1:nFiles
    % Data
    indFile = File == f;
    time = Timeframe(indFile);      % Time column
    x = xPospx(indFile)*pxlSz;            % X coordinates
    y = yPospx(indFile)*pxlSz;            % Y coordinates
    EffRaw = Eraw(indFile);
    EffPR = EPR(indFile);
    Eff = E(indFile);
    StoiRaw = Sraw(indFile);
    StoiPR = SPR(indFile);
    StoiGamma = Sgamma(indFile);
    StoiGammaBeta = Sgammabeta(indFile);
    

    % Unique frames in the dataset
    unique_frames = unique(time);

    % Track ID counter
    track_id = 1;

    % Loop over frames and link particles
    tracks = [];  % Store tracks as [id, frame, x, y, ...]

    for i = 1:length(unique_frames) - 1
        frame_t1 = unique_frames(i);
        frame_t2 = unique_frames(i + 1);

        % Get particle positions at current and next frames
        idx_t1 = time == frame_t1;
        idx_t2 = time == frame_t2;

        particles_t1 = [x(idx_t1), y(idx_t1), EffRaw(idx_t1), ...
            EffPR(idx_t1), Eff(idx_t1), StoiRaw(idx_t1), ...
            StoiPR(idx_t1), StoiGamma(idx_t1), StoiGammaBeta(idx_t1)];
        particles_t2 = [x(idx_t2), y(idx_t2), EffRaw(idx_t2), ...
            EffPR(idx_t2), Eff(idx_t2), StoiRaw(idx_t2), ...
            StoiPR(idx_t2), StoiGamma(idx_t2), StoiGammaBeta(idx_t2)];
        
        % If no particles in one of the frames, continue
        if isempty(particles_t1) && isempty(particles_t2)
            continue
        end

        % Compute Euclidean distances between particles in frame t1 and t2
        distances = pdist2(particles_t1(:,1:2), particles_t2(:,1:2));

        % Update particle tracks
        for j = 1:size(distances, 1)
            t1_idx = j;
            t2_idx = find(distances(j,:)==min(distances(j,:)));

            if  distances(t1_idx, t2_idx) < maxStep
                % Link existing particle
                p1 = particles_t1(t1_idx, 1:2);
                p2 = particles_t2(t2_idx, 1:2);
                ES1 = particles_t1(t1_idx, 3:9);
                ES2 = particles_t2(t2_idx, 3:9);
                % Update track with existing particle ID
                if ~isempty(tracks)
                    track_id_current = tracks(tracks(:, 2) == frame_t1 & ...
                        tracks(:, 3) == p1(1) & tracks(:, 4) == p1(2), 1);
                    if length(track_id_current)>1
                        track_id_current = track_id_current(1);
                    end
                else
                    track_id_current = [];
                end
                if isempty(track_id_current)
                    track_id_current = track_id;
                    track_id = track_id + 1;
                    tracks = [tracks; track_id_current, frame_t1, ...
                        p1(1), p1(2), ES1];
                end
                tracks = [tracks; track_id_current, frame_t2, p2(1), ...
                    p2(2), ES2];
            end
        end
    end

    % Plot particle tracks
    if showNNplots
        figure(2*(f-1)+1);
        hold on;
    end
    unique_ids = unique(tracks(:, 1));
    colors = lines(length(unique_ids));
    nTracks(f) = length(unique_ids);
    for i = 1:nTracks(f)
        if f==1
            start_i = 0;
        else
            csum = cumsum(nTracks(1:f-1));
            start_i = csum(end);
        end
        particleTracks(start_i+i).cell = f;
        particleTracks(start_i+i).id = unique_ids(i);
        particleTracks(start_i+i).time_s = tracks(tracks(:, 1) == ...
            unique_ids(i), 2)*dt;
        particleTracks(start_i+i).x_um = tracks(tracks(:, 1) == unique_ids(i), 3);
        particleTracks(start_i+i).y_um = tracks(tracks(:, 1) == unique_ids(i), 4);
        particleTracks(start_i+i).Eraw = tracks(tracks(:, 1) == unique_ids(i), 5);
        particleTracks(start_i+i).EPR = tracks(tracks(:, 1) == unique_ids(i), 6);
        particleTracks(start_i+i).E = tracks(tracks(:, 1) == unique_ids(i), 7);
        particleTracks(start_i+i).Sraw = tracks(tracks(:, 1) == unique_ids(i), 8);
        particleTracks(start_i+i).SPR = tracks(tracks(:, 1) == unique_ids(i), 9);
        particleTracks(start_i+i).Sgamma = tracks(tracks(:, 1) == ...
            unique_ids(i), 10);
        particleTracks(start_i+i).Sgammabeta = tracks(tracks(:, 1) == ...
            unique_ids(i), 11);
        if showNNplots
            particle_track = tracks(tracks(:, 1) == unique_ids(i), :);
            if size(particle_track,1) >= trLenForPlot
                plot(particle_track(:, 3), particle_track(:, 4), '-', 'Color',...
                    colors(i, :), 'LineWidth', 2);
            end
        end
    end
    if showNNplots
        xlabel('X (µm)');
        ylabel('Y (µm)');
        title(['File ',int2str(f),': Particle Tracks (nearest neighbor linking)']);
        hold off;
        set(gca, 'YDir', 'reverse');
    end
    nIDs = length(unique_ids);
    trackLinking = zeros(nIDs,8);
    linkedTracks = [];

    for i = 1:nIDs
        myID = unique_ids(i);
        myTrack = tracks(tracks(:,1)==myID,:);
        startFrame = myTrack(1,2);
        endFrame = myTrack(end,2);
        trLen = endFrame-startFrame+1;
        xStart = myTrack(1,3);
        yStart = myTrack(1,4);
        xEnd = myTrack(end,3);
        yEnd = myTrack(end,4);
        trackLinking(i,:) = [myID, startFrame, endFrame, trLen, ...
            xStart, yStart, xEnd, yEnd];
    end

    nLinked = 0;
    for i = 1:nIDs
        endTime = trackLinking(i,3);
        particleTrackEnd = [trackLinking(i,7) , trackLinking(i,8)];
        indCandidates = find(trackLinking(:,2) >= endTime + 1 & ...
            trackLinking(:,2) < endTime + nFrGapClosure + 1);
        if isempty(indCandidates)
            continue;
        end
        nFoundIDsforLinking = length(indCandidates);
        IDCandidates = trackLinking(indCandidates,1);
        particlesCandidates = [trackLinking(indCandidates,5),...
            trackLinking(indCandidates,6)];
        % Compute Euclidian distances between particles in frame t1 and t2
        distances = pdist2(particleTrackEnd, particlesCandidates);
        shortestDistance = min(distances);
        indShortestDistance = find(distances==shortestDistance);
        if shortestDistance < maxStepGapClosure
            nLinked = nLinked + 1;
            linkedTracks(nLinked,:) = [i, IDCandidates(indShortestDistance)];
        end
    end
    if ~isempty(linkedTracks)
        linkedTracksAll = struct();
        linkedTracksSearch = linkedTracks;
        %remove links which link multiple tracks
        for i=1:nIDs
            ind = linkedTracks(:,2)==i;
            if nnz(ind)>=2
                linkedTracksSearch(ind,:)=0;
            end
        end

        n=1;
        for i=1:nLinked
            foundLink = true;
            if linkedTracksSearch(i,1) == 0
                continue;
            end
            link = linkedTracksSearch(i,:);
            findLink = link(2);
            while (foundLink)
                ind = linkedTracksSearch(:,1) == findLink;
                if nnz(ind)==0
                    foundLink = false;
                    continue;
                end
                newLink = horzcat(link, linkedTracksSearch(ind,2)');
                linkedTracksSearch(ind,:) = 0;
                link = newLink;
                findLink = link(end);
            end
            linkedTracksAll(n).IDs = link;
            n = n + 1;
        end

        nLinksFinal = size(linkedTracksAll,2);
        tracksFinal = tracks;
        for i=1:nLinksFinal
            finalID = linkedTracksAll(i).IDs(1);
            for j=2:size(linkedTracksAll(i).IDs,2)
                ind = tracks(:,1) == linkedTracksAll(i).IDs(j);
                tracksFinal(ind,1) = finalID;
            end
        end
    else
        tracksFinal = tracks;
    end
    % Plot particle tracks
    if showNNplots
        figure(2*(f-1)+2);
    else
        figure(f);
    end
    hold on;
    unique_ids_final = unique(tracksFinal(:, 1));
    colors = lines(length(unique_ids_final));
    nTracksGapClosure(f) = length(unique_ids_final);
    for i = 1:nTracksGapClosure(f)
        if f==1
            start_i = 0;
        else
            csum = cumsum(nTracksGapClosure(1:f-1));
            start_i = csum(end);
        end
        particleTracksGapClosure(start_i+i).cell = f;
        particleTracksGapClosure(start_i+i).id = i;
        particleTracksGapClosure(start_i+i).time_s = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 2)*dt;
        particleTracksGapClosure(start_i+i).x_um = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 3);
        particleTracksGapClosure(start_i+i).y_um = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 4);
        particleTracksGapClosure(start_i+i).Eraw = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 5);
        particleTracksGapClosure(start_i+i).EPR = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 6);
        particleTracksGapClosure(start_i+i).E = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 7);
        particleTracksGapClosure(start_i+i).Sraw = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 8);
        particleTracksGapClosure(start_i+i).SPR = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 9);
        particleTracksGapClosure(start_i+i).Sgamma = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 10);
        particleTracksGapClosure(start_i+i).Sgammabeta = tracksFinal(...
            tracksFinal(:, 1) == unique_ids_final(i), 11);
        particle_track = tracksFinal(tracksFinal(:, 1) == ...
            unique_ids_final(i), :);
        if size(particle_track,1) >= trLenForPlot
            E_plot = particle_track(:,7);
            E_plot(E_plot<0) = 0;
            E_plot(E_plot>1) = 1;
            E_plot_scaled = round(E_plot*(size(cmap, 1) - 1)) + 1;
            lenTr = size(E_plot_scaled,1);
            for p=1:lenTr-1
            plot(particle_track(p:p+1, 3), particle_track(p:p+1, 4), '-', 'Color',...
                cmap(E_plot_scaled(p),:), 'LineWidth', 2);
            end
        end
    end
    % Add colorbar
    cbar = colorbar;
    cbar.Label.String = 'FRET Efficiency';
    cbar.Ticks = linspace(0, 1, 5); % Set ticks for the colorbar
    cbar.TickLabels = arrayfun(@(x) sprintf('%.2f', x), ...
        linspace(0, 1, 5), 'UniformOutput', false); % Custom tick labels
    xlabel('X (µm)');
    ylabel('Y (µm)');
    title(['Cell ',int2str(f),': Particle Tracks (nearest neighbor',...
        ' linking with gap closure)']);
    hold off;
    
    % Set equal scaling to avoid skewing
    axis equal;
    set(gca, 'YDir', 'reverse');
    
    % Set fixed symmetric limits for both axes
    x_limits = [0, xmax]; % Change these values as needed
    y_limits = [0, ymax]; % Change these values as needed
    xlim(x_limits);
    ylim(y_limits);

    savefig([saveDir, '\Cell_',int2str(f),'_tracks_with_FRET_E.fig']);
    saveas(gcf, [saveDir, '\Cell_',int2str(f),'_tracks_with_FRET_E.png']);
end
save([saveDir,'\smFRET_tracking_results_all.mat']);